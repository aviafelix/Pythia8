<chapter name="Event Information">

<h2>Event Information</h2>

The <code>Info</code> class collects various one-of-a-kind information, 
some relevant for all events and others for the current event. 
An object <code>info</code> is a public member of the <code>Pythia</code>
class, so if you e.g. have declared <code>Pythia pythia</code>, the
<code>Info</code> methods can be accessed by 
<code>pythia.info.method()</code>. Most of this is information that 
could also be obtained e.g. from the event record, but is here more
directly available. It is intended for processes generated internally
in Pythia8, not for ones read in e.g. via the Les Houches Accord.

Here are the currently available methods:

<method name="list()">
a listing of most of the information set for the current event. 
</method>

<method name="idA(), idB()">
the identities of the two beam particles. 
</method>

<method name="pzA(), pzB()"> 
the longitudinal momenta of the two beam particles.
</method>

<method name="eA(), eB()"> 
the energies of the two beam particles.
</method>

<method name="mA(), mB()"> 
the masses of the two beam particles.
</method>

<method name="eCM(), s()"> 
the cm energy and its square for the two beams. 
</method>

<method name="name(), code()"> 
the name and code of the process that occured.
</method>

<method name="nFinal()"> 
the number of final-state partons in the hard process.
</method>

<method name="isResolved()"> 
are beam particles resolved, i.e. were PDF's used for the process?
</method>

<method name="isDiffractiveA(), isDiffractiveB()"> 
is either beam diffractively excited?
</method>

<method name="isMinBias()"> 
is the process a minimum-bias one?
</method>

<method name="hasSub()"> 
does the process have a subprocess classification?
Currently only true for minbias, where it allows the hardest
collision to be identified.
</method>

<method name="nameSub(), codeSub(), nFinalSub()"> 
the name, code and number of final-state partons in the subprocess
that occured when <code>hasSub()</code> is true. For instance, for 
a minimum-bias event the <code>code</code> would always be 101,
while <code>codeSub()</code> would vary depending on the actual
hardest interaction, e.g. 111 for <ei>g g -> g g</ei>. The methods
below would also provide information for this particular subcollision.  
</method>

<method name="id1(), id2()"> 
the identities of the two partons coming in to the hard process.
</method>

<method name="x1(), x2()"> 
<ei>x</ei> fractions of the two partons coming in to the hard process.
</method>

<method name="y(), tau()"> 
rapidity and scaled mass-squared of the hard-process subsystem, as 
defined by the above <ei>x</ei> values. 
</method>

<method name="pdf1(), pdf2()"> 
parton densities <ei>x*f(x,Q^2</ei> )evaluated for the two incoming 
partons; could be used e.g. for reweighting purposes. 
</method>

<method name="QFac(), Q2Fac()"> 
the <ei>Q^2</ei> or <ei>Q^2</ei> factorization scale at which the 
densities were evaluated.
</method>

<method name="alphaS(), alphaEM()"> 
the <ei>alpha_strong</ei> and <ei>alpha_electromagnetic</ei> values used 
for the hard process.
</method>

<method name="QRen(), Q2Ren()"> 
the <ei>Q</ei> or <ei>Q^2</ei> renormalization scale at which 
<ei>alpha_strong</ei> and <ei>alpha_electromagnetic</ei> were evaluated.
</method>

<method name="mHat(), sHat()">
the invariant mass and its square for the hard process.
</method>

<method name="tHat(), uHat()"> 
the remaining two Mandelstam variables; only defined for <ei>2 -> 2</ei>
processes. 
</method>

<method name="pTHat(), pT2Hat()"> 
transverse momentum and its square in the rest frame of a <ei>2 -> 2</ei>
processes. 
</method>

<method name="m3Hat(), m4Hat()"> 
the masses of the two outgoing particles in a <ei>2 -> 2</ei> processes. 
</method>

<method name="thetaHat(), phiHat()"> 
the polar and azimuthal scattering angles in the rest frame of 
a <ei>2 -> 2</ei> process.
</method>

<method name="nTried(), nAccepted()">
the total number of tried phase-space points and accepted events, 
summed over all allowed subprocesses.

<method name="sigmaGen(), sigmaErr()">
the estimated cross section and its estimated error,
summed over all allowed subprocesses, in units of mb. 

<method name="bMI()"> 
the impact parameter <ei>b</ei> assumed for the current collision when
multiple interactions are simulated. Is not expressed in any physical
size (like fm), but only rescaled so that the average should be unity 
for minimum-bias events (meaning less than that for events with hard
processes). 
</method>

<method name="enhanceMI()"> 
The choice of impact parameter implies an enhancement or depletion of
 the rate of subsequent interactiosn, as given by this number. Again
the average is normalized be unity for minimum-bias events (meaning 
more than that for events with hard processes).  
</method>

<method name="nMI()"> 
the number of hard interactions in the current event. Is 0 for elastic
and diffractive events, and else at least 1, with more possible from
multiple interactions.
</method>

<method name="codeMI(i), pTMI(i)"> 
the process code and transverse momentum of the <code>i</code>'th 
subprocess, with <code>i</code> in the range from 0 to
<code>nMI() - 1</code>. The values for subprocess 0 is redundant with
information already provided above.  
</method>

<method name="nISR(), nFSRinProc(), nFSRinRES()"> 
the number of emissions in the initial-state showering, in the final-state
showering excluding resonance decys, and in the final-state showering
inside resonance decays, respectively. Not yet fully implemented.  
</method>

</chapter>

<!-- Copyright C 2007 Torbjorn Sjostrand -->
