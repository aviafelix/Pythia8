<chapter name="Parton Distributions">

<h2>Parton Distributions</h2>

The parton distributions file contains the <code>PDF</code> class (an 
abbreviation hopefully so well accepted that it is used in many places 
of the code, instead of writing it out in full). <code>PDF</code> is the 
base class, from which specific <code>PDF</code> classes are derived.

<p/>
The choice of which PDF to use is made by a switch in the <code>Pythia</code> 
class, see the Generic Settings page. Thus there is no need for a normal 
user to study this class. The structure must be understood when interfacing 
new PDF's, however. 

<h3>The PDF base class</h3>

<code>PDF</code> defines the interface that all PDF classes should respect.
The constructor requires the incoming beam species to be given:
even if used for a proton PDF, one needs to know whether the beam
is actually an antiproton. This is one of the reasons why <code>Pythia</code> 
always defines two PDF objects in an event, one for each beam.

<p/>
Once a <code>PDF</code> object has been constructed, call it <code>pdf</code>, 
the main method is <code>pdf.xf( id, x, Q2)</code>, which returns 
<ei>x*f_id(x, Q2)</ei>, properly taking into account whether the beam 
is an antiparticle or not.

<p/>
Whenever the <code>xf</code> member is called with a new flavour, <ei>x</ei> 
or <ei>Q^2</ei>, the <code>xfUpdate</code> member is called to do the actual 
updating. This routine may either update that particular flavour or all 
flavours at this <ei>(x, Q^2)</ei> point. (In the latter case the saved 
<code>id</code> value <code>idSav</code> should be set to 9.) The choice is 
to be made by the producer of a given set, based on what he/she deems most 
effective, given that sometimes only one flavour need be evaluated, and 
about equally often all flavours are needed at the same <ei>x</ei> and 
<ei>Q^2</ei>. Anyway, the latest value is always kept in memory. This is 
the other reason why <code>Pythia</code> has one separate <code>PDF</code> 
object for each beam, so that values at different <ei>x</ei> can be kept 
in memory. 

<h3>Derived classes</h3>

There is only one pure virtual method, <code>xfUpdate</code>, that therefore 
must be implemented in any derived class. Currently the list of such 
classes is tiny:

<p/>
For protons:
<ul>
<li>GRV94L gives the GRV 94 L parametrization <ref>Glu95</ref>.</li>
<li>CTEQ5L gives the CTEQ 5 L parametrization <ref>Lai00</ref>.</li>
</ul>
The default is CTEQ 5L, which is the most recent of the two.

<p/>
For charged leptons (e, mu, tau): 
<ul>
<li>Lepton gives a QED parametrization <ref>Kle89</ref>.
In QED there are not so many ambiguities, so here one set should be 
enough. On the other hand, there is the problem that the 
lepton-inside-lepton pdf is integrably divergent for <ei>x -> 1</ei>, 
which gives numerical problems. Like in PYTHIA 6, the pdf is therefore
made to vanish for <ei>x > 1 - 10^{-10}</ei>, and scaled up in the range
<ei>1 - 10^{-7} &lt; x &lt; 1 - 10^{-10}</ei> in such a way that the 
total area under the pdf is preserved.</li>
</ul>   

</chapter>

<!-- Copyright C 2006 Torbjorn Sjostrand -->
