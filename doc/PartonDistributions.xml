<chapter name="Parton Distributions">

<h1>Parton Distributions</h1>

The parton distributions file contains the <ci>PDF</ci> class (an 
abbreviation hopefully so well accepted that it is used in many places 
of the code, instead of writing it out in full). <ci>PDF</ci> is the 
base class, from which specific <ci>PDF</ci> classes are derived.

The choice of which PDF to use is made by a switch in the <ci>Pythia</ci> 
class, see the Generic Settings page. Thus there is no need for a normal 
user to study this class. The structure must be understood when interfacing 
new PDF's, however. 

<h2>The PDF base class</h2>

<ci>PDF</ci> defines the interface that all PDF classes should respect.
The constructor requires the incoming beam species to be given:
even if used for a proton PDF, one needs to know whether the beam
is actually an antiproton. This is one of the reasons why <ci>Pythia</ci> 
always defines two PDF objects in an event, one for each beam.

Once a <ci>PDF</ci> object has been constructed, call it <ci>pdf</ci>, 
the main method is <ci>pdf.xf( id, x, Q2)</ci>, which returns 
<ei>x*f_id(x, Q2)</ei>, properly taking into account whether the beam 
is an antiparticle or not.

Whenever the <ci>xf</ci> member is called with a new flavour, <ei>x</ei> 
or <ei>Q^2</ei>, the <ci>xfUpdate</ci> member is called to do the actual 
updating. This routine may either update that particular flavour or all 
flavours at this <ei>(x, Q^2)</ei> point. (In the latter case the saved 
<ci>id</ci> value <ci>idSav</ci> should be set to 9.) The choice is to be 
made by the producer of a given set, based on what he/she deems most 
effective, given that sometimes only one flavour need be evaluated, and 
about equally often all flavours are needed at the same <ei>x</ei> and 
<ei>Q^2</ei>. Anyway, the latest value is always kept in memory. This is 
the other reason why <ci>Pythia</ci> has one separate <ci>PDF</ci> object 
for each beam, so that values at different <ei>x</ei> can be kept in memory. 

<h2>Derived classes</h2>

There is only one pure virtual method, <ci>xfUpdate</ci>, that therefore 
must be implemented in any derived class. Currently the list of such 
classes is tiny:

<p/>
For protons:
<ul>
<li>GRV94L gives the GRV 94 L parametrization [1].</li>
<li>CTEQ5L gives the CTEQ 5 L parametrization [2].</li>
</ul>
The default is CTEQ 5L, which is the most recent of the two.

<p/>
For charged leptons (e, mu, tau): 
<ul>
<li>Lepton gives a QED parametrization [3].
In QED there are not so many ambiguities, so here one set should be 
enough. On the other hand, there is the problem that the 
lepton-inside-lepton pdf is integrably divergent for <ei>x -> 1</ei>, 
which gives numerical problems. Like in Pythia6, the pdf is therefore
made to vanish for <ei>x > 1 - 10^{-10}</ei>, and scaled up in the range
<ei>1 - 10^{-7} &lt; x &lt; 1 - 10^{-10}</ei> in such a way that the 
total area under the pdf is preserved.</li>
</ul>   

<h2>References</h2>

<ol>
 
<li>M. Gluck, E. Reya and A. Vogt, Z. Phys. C67 (1995) 433</li>

<li>CTEQ Collaboration, H.L. Lai et al., 
Eur. Phys. J. C12 (2000) 375</li>

<li>R. Kleiss et al., in `Z physics at LEP 1', 
eds. G. Altarelli, R. Kleiss and C. Verzegnassi, 
CERN 89-08 (Geneva, 1989), Vol. 3, p. 143</li>

</ol>

</chapter>

<!-- Copyright C 2006 Torbjorn Sjostrand -->
