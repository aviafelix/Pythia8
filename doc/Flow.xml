<chapter name="Program Flow">

<h2>Program Flow</h2>

Recall that, to first order, the event generation process can be 
subdivided into three stages:
<ol>
<li>Initialization.</li>
<li>The event loop.</li>
<li>Finishing.</li>
</ol>
This is reflected in how the top-level <code>Pythia</code> class should 
be used in the user-supplied main program, further outlined in the 
following.

<h3>Initialization</h3>

<ol>

<li>Already at the top of the main program file, you need to
include the proper header file
<pre>
    #include "Pythia.h"
</pre>
To simplify typing, it also makes sense to declare
<pre>
    using namespace Pythia8; 
</pre></li>

<li>(compulsory) The first step is to create a generator object, 
e.g. with
<pre>
     Pythia pythia;
</pre>
It is this object that we will use from now on. Normally a run
will only contain one <code>Pythia</code> object, but hypothetically 
you  could use several.<br/>
All output from <code>Pythia</code> will be on the <code>cout</code> 
stream. If this is not convenient, you can give a reference to another 
stream as an optional argument
<pre>
    Pythia pythia(ostream);
</pre>
but this does not work so far! (??)</li>  

<li>(compulsory, or to be replaced by next point) You next want to 
set up the character of the run. 
The pages under the "Setup Run Parameters" heading in the index
describe all the options available. The default values and your
modifications are stored in two databases, one for
<a href="SettingsScheme.xml" target="page">generic settings</a>
and one for <a href="ParticleDataScheme.xml" target="page">
particle data</a>. Both of these are static classes, and are 
initialized with their default values by the <code>Pythia</code> 
constructor. A third static class, eventually to disappear, is the 
interface to the old Fortran 77 PYTHIA 6, currently used for 
generating hard processes.<br/> You can use the dedicated methods 
of each class to change the database default 
values to fit the needs of your current run. However, the
<pre>
    pythia.readString(string)
</pre>
method provides a covenient uniform interface to all three of them.
The information in the string is case-insensitive, but upper- and
lowercase can be combined for clarity. The rules are that<br/>
(i) if the first nonblank character of the string is not a 
letter or a digit nothing will be done;<br/>
(ii) if the string begins with <code>Pythia6:</code>, this part is peeled 
off, and the rest is sent on to Fortran PYTHIA 6, using the 
<code>pygive</code> method in that package;<br/>
(iii) if the string begins with a digit it is assumed to contain 
particle data updates, and so sent on to 
<code>pythia.particleData.readString(string)</code>;<br/>
(iv) if none of the above, the string is assumed to contain a  
setting, and is sent on to 
<code>pythia.settings.readString(string)</code>.<br/> 
In the latter two cases, a warning is issued whenever a string
cannot be recognized (maybe because of a spelling mistake),
unless an optional second argument <code>false</code> is used to 
switch off warnings.<br/>
Some examples would be
<pre>
    pythia.readString("Pythia6:msel = 6");
    pythia.readString("111:mayDecay = false");
    pythia.readString("TimeShower:pTmin = 1.0");
</pre>
The methods in this paragraph are intended for small changes; for more 
extensive ones it is better to store all the changes in a file, see next.
</li>

<li>(alternative to previous point) You can read in a file containing a 
list of those variables you want to see changed, with a 
<pre>
    pythia.readFile(fileName);
</pre>
Each line in this file with be processes by the 
<code>pythia.readString()</code> method introduced above. You can thus 
freely mix comment lines and lines handed on to <code>Settings</code>, 
<code>ParticleDataTable</code> and <code>Pythia6</code>.   
This would be the normal way to set up what a run is supposed 
to do. Again, an optional second argument <code>false</code> allows you to 
switch off warning messages for unknown variables.<br/>
Of course, if your file is also supposed to contain commands 
to other libraries, so you have to build your own parser, the 
<code>readString</code> method above may be more appropriate.</li>

<li>(optional) If you are not satisfied with the (short) list of 
parton density functions that are implemented internally in 
<code>Pythia</code>, you can suppy your own by a call to the 
<code>PDFptr</code> method
<pre>
      pythia.PDFptr( pdfA, pdfB); 
</pre>
where <code>pdfA</code> and <code>pdfB</code> are pointers to two 
<code>Pythia</code> PDF objects 
(<a href="PartonDistributions.xml" target="page">further 
instructions</a>). 
Note that <code>pdfA</code> and <code>pdfB</code> cannot point to 
the same object; even if the PDF set is the same, two copies are 
needed to keep track of two separate sets of <ei>x </ei>and density 
values.</li>

<li>(optional) If you want to perform some particle decays with an
external generator, you can call the <code>decayPtr</code> method
<pre>
      pythia.decayPtr( decayHandler, particles)
</pre>
where the <code>decayHandler</code> derives from the 
<code>DecayHandler</code> base class and <code>particles</code> is a 
vector of particle codes to be handled 
(<a href="ExternalDecays.xml" target="page">further instructions</a>). 
</li>

<li>(optional) If you want to use an external random number generator, 
you can call the <code>rndmEnginePtr</code> method
<pre>
      pythia.rndmEnginePtr( rndmEngine) 
</pre>
where <code>rndmEngine</code> derives from the <code>RndmEngine</code> 
base class (<a href="RandomNumbers.xml" target="page">further 
instructions</a>). The <code>Pythia</code> default random number 
generator is perfectly good, so this is only intended for consistency 
in bigger frameworks.</li>

<li>(compulsory) Next comes the initialization stage, where all 
remaining details of the generation are to be specified. The 
<code>init</code> method allows a few different input formats, 
so you can pick the one convenient for you:<br/>
a) pythia.init( idA, idB, eA, eB);<br/>
lets you specify the identities and energies of the two incoming
beam particles, with A (B) assumed moving in the <ei>+z (-z)</ei> 
direction.<br/>
b) pythia.init( idA, idB, eCM);<br/>
is similar, but you specify the CM energy, and you are assumed 
in the rest frame.<br/>
c) pythia.init( LHAinit*, LHAevnt*); <br/>
assumes Les Houches Accord initialization information is available 
in an <code>LHAinit</code> class object, and that LHA event information 
will be provided by the <code>LHAevnt</code> class object
(<a href="LesHouches.xml" target="page">further instructions</a>).</li>

<li>(optional) If you want to have a list of the generator and
particle data used, either only what has been changed or everything, 
you can use 
<pre>
    pythia.settings.listChanged();
    pythia.settings.listAll();
    pythia.particleData.listChanged(); 
    pythia.particleData.listAll(); 
</pre></li>
</ol>

<h3>The event loop</h3>

<ol>
<li>(compulsory) Inside the event generation loop you generate the 
next event using the <code>next</code> method,
<pre>
    pythia.next();
</pre>
This method takes no arguments; everything has already been specified. 
It does return a bool value, however, <code>false</code> when the
generation failed. This can be a "programmed death" when the
supply of input parton-level configurations on file is exhausted,
but also caused by a failure of <code>Pythia</code> to generate an event,
or that an event was generated but something strange was detected
in it.</li>  
 
<li>(optional) The generated event is now stored in the <code>event</code> 
object, of type <code>Event</code>, which is a public member of 
<code>pythia</code>. You therefore have access to all the tools described
on the pages under the "Study Output" header in the index. For instance, 
an event can be listed with 
<code>pythia.event.list()</code>, the identity of the <ei>i</ei>'th 
particle is given by <code>pythia.event[i].id()</code>, and so on.<br/> 
Furthermore, the hard process - roughly the information normally 
stored in the Les Houches Accord event record - is available as 
a second object, <code>process</code>, also of type 
<code>Event</code>.</li> 

</ol>

<h3>Finishing</h3>

<ol>

<li>(optional) At the end of the generation process, you can call
<pre>
    pythia.statistics(); 
</pre>
to get some run statistics, on cross sections and the number of errors 
and warnings encountered.</li> 

</ol>

</chapter>

<!-- Copyright C 2006 Torbjorn Sjostrand -->
