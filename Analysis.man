
      Analysis
      ========

The routines in this section are intended to be used to analyze
event properties. As such they are not part of the main event
generation chain, but can be used in comparisons between Monte
Carlo events and real data. They are rather free-standing, but 
assume that input is provided in the Pythia8 Event format, and
use a few basic facilities such as four-vectors.

---------------------------------------------------------------------- 

   Sphericity
   ----------

The standard sphericity tensor is
    S^{ab} = (sum_i p_i^a p_i^b) / (sum_i p_i^2)
where the sum i runs over the particles in the event,
a, b = x, y, z, and p without such an index is the absolute
size of the three-momentum . This tensor can be diagonalized 
to find eigenvalues and eigenvectors.

The above tensor can be generalized by introducing a power r,
such that
    S^{ab} = = (sum_i p_i^a p_i^b p_i^{r-2}) / (sum_i p_i^r)
In particular, r = 1 gives a linear dependende on momenta and
thus a collinear safe definition, unlike sphericity.

A sphericity analysis object is declared by
   Sphericity sph( power, select)
(or any other name instead of sph) where 
   power (default 2.) is the power r defined above, i.e. 
      = 2. gives Spericity, and 
      = 1. the linear form.
   select (default = 2) tells which particles are analyzed,
      = 1 all final-state particles,
      = 2 all observable final-state particles, i.e. excluding
          neutrinos and other particles without strong or
          electromagnetic interactions (the isInvisible()
          particle method), and
      = 3 only charged final-state particles.

The analysis is performed by a
   sph.analyze( event)
where event is an object of the Event class, most likely the 
pythia.event one. If the routine returns false the analysis 
failed, e.g. if too few particles are present to analyze.

After the analysis has been performed, a few methods are available
to return the result of the analysis:
   sph.sph() gives the sphericity (or equivalent if r is not 2),
   sph.apl() gives the aplanarity (with the same comment),
   sph.eigenValue(i) gives one of the three eigenvalues for
      i = 1, 2 or 3, in descending order,
   sph.EigenVector(i) gives the matching eigenvector, as a Vec4
      with vanishing time/energy component.
   sph.list() provides a listing of the above information.

---------------------------------------------------------------------- 

   CellJet
   -------

CellJet (a.k.a. PYCELL) is a simple cone jet finder in the UA1 spirit, 
see the Pythia6 manual. It works in an (eta, phi, eT) space, where
eta is pseudorapidity, phi azimuthal angle and eT transverse energy.
It will draw cones in R = sqrt(Delta-eta^2 + Delta-phi^2) around
seed cells. If the total eT inside the cone exceeds the threshold,
a jet is formed, and the cells are removed from further analysis.
There are no split or merge procedures, so later-found jet may be
missing some of the edge regions already used up by previous ones.   

A cell jet analysis object is declared by
    CellJet cellJet( eTjetMin, coneRadius, select, etaMax, nEta,
      nPhi, eTseed, smear, resolution, upperCut, threshold)
(or any other name instead of cellJet) where 
   eTjetMin (default 20. GeV) is the minimum transverse energy 
      inside a cone for this to be accepted as a jet.
   coneRadius (default = 0.7) is the size of the cone in (eta, phi)
      space drawn around the geometric center of the jet.
   select (default = 2) tells which particles are analyzed,
      = 1 all final-state particles,
      = 2 all observable final-state particles, i.e. excluding
          neutrinos and other particles without strong or
          electromagnetic interactions (the isInvisible()
          particle method), and
      = 3 only charged final-state particles.
   etaMax (default = 5.) the maximum +-pseudorapidity that the
      detector is assumed to cover.
   nEta (default = 50) the number of equal-sized bins that the
      +-etaMax range is assumed to be divided into.
   nPhi (default = 32) the number of equal-sized bins that the
      phi range +-pi is assumed to be divided into. 
   eTseed (default = 1.5 GeV) the mimimum eT in a cell for this 
      to be acceptable as the trial center of a jet. 
   smear, resolution, upperCut (defaults = 0, 0.5, 2.) strategy to 
      smear the actual eT bin by bin,
      = 0 no smearing,
      = 1 smear the eT according to a Gaussian with width   
          resolution * sqrt(eT), with the Gaussian truncated at 0
          and upperCut * eT,
      = 2 smear the e = eT * cosh(eta) according to a Gaussian with 
          width resolution * sqrt(e), with the Gaussian truncated 
          at 0 and upperCut * e.
   threshold (default = 0 GeV) completely neglect all bins with an
      eT < threshold.

The analysis is performed by a
   cellJet.analyze( event)
where event is an object of the Event class, most likely the 
pythia.event one. If the routine returns false the analysis 
failed, but currently this is not foreseen ever to happen.

After the analysis has been performed, a few methods are available
to return the result of the analysis:
   cellJet.size() gives the number of jets found,
   cellJet.eT(i) gives the eT of the i'th jet, where jets have been
      ordered with decreasing eT values,
   cellJet.etaCenter(i) and cellJet.phiCenter(i) gives the eta and
      phi coordinates of the geometrical center of the i'th jet,
   cellJet.etaWeighted(i) and cellJet.phiWeighted(i) gives the eta 
      and phi coordinates of the eT-weighted center of the i'th jet,
   cellJet.multiplicity(i) gives the number of particles clustered
      into the i'th jet,
   cellJet.pMassless(i) gives a Vec4 corresponding to the four-momentum
      defined by the eT and the weighted center of the i'th jet,
   cellJet.pMassive(i) gives a Vec4 corresponding to the four-momentum
      defined by the sum of all the contributing cells to the i'th jet, 
      where each cell contributes a four-momentum as if all the eT is 
      deposited in the center of the cell,
   cellJet.m(i) gives the invariant mass of the i'th jet, defined
      by the pMassive above,
   cellJet.list() provides a listing of the above information (except
      pMassless, for reasons of space).

---------------------------------------------------------------------- 

Copyright C 2006 Torbjorn Sjostrand
